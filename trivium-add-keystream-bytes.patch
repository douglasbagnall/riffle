--- a/trivium.c	2006-02-24 11:16:21.000000000 +1300
+++ b/trivium.c	2011-04-17 13:36:04.214875003 +1200
@@ -1,6 +1,6 @@
 /* trivium.c */
 
-/* 
+/*
  * Reference implementation of the TRIVIUM stream cipher
  *
  * Author: Christophe De Canni\`ere, K.U.Leuven.
@@ -13,7 +13,7 @@
 /* ------------------------------------------------------------------------- */
 
 /*
- * *** WARNING *** 
+ * *** WARNING ***
  *
  * This implementation uses the following ordering of the key and iv
  * bits during initialization:
@@ -194,8 +194,8 @@
 /* ------------------------------------------------------------------------- */
 
 void ECRYPT_keysetup(
-  ECRYPT_ctx* ctx, 
-  const u8* key, 
+  ECRYPT_ctx* ctx,
+  const u8* key,
   u32 keysize,
   u32 ivsize)
 {
@@ -218,7 +218,7 @@
 /* ------------------------------------------------------------------------- */
 
 void ECRYPT_ivsetup(
-  ECRYPT_ctx* ctx, 
+  ECRYPT_ctx* ctx,
   const u8* iv)
 {
   const u32 ivlen = LOAD_IVLEN(ctx->init[0]);
@@ -249,7 +249,7 @@
   for (i = 0; i < 9; ++i)
     {
       m64 t1, t2, t3;
-      
+
       UPDATE(); ROTATE();
       UPDATE(); ROTATE();
     }
@@ -263,9 +263,9 @@
 
 void ECRYPT_process_bytes(
   int action,
-  ECRYPT_ctx* ctx, 
-  const u8* input, 
-  u8* output, 
+  ECRYPT_ctx* ctx,
+  const u8* input,
+  u8* output,
   u32 msglen)
 {
   m64 s11, s12;
@@ -277,7 +277,7 @@
   for ( ; (int)(msglen -= 16) >= 0; output += 16, input += 16)
     {
       m64 t1, t2, t3, z[2];
-      
+
       UPDATE(); z[0] = XOR(XOR(s12, s22), s32); ROTATE();
       UPDATE(); z[1] = XOR(XOR(s12, s22), s32); ROTATE();
 
@@ -288,7 +288,7 @@
   for (msglen += 16; (int)msglen > 0; msglen -= 8, output += 8, input += 8)
     {
       m64 t1, t2, t3, z;
-      
+
       UPDATE();
       z = XOR(XOR(s12, s22), s32);
 
@@ -313,4 +313,35 @@
   EMPTY();
 }
 
+#ifndef debug
+#include <stdio.h>
+#define debug(format, ...) fprintf (stderr, (format),## __VA_ARGS__); fflush(stderr)
+#endif
+/* only deal with multiples of 16 */
+void ECRYPT_keystream_bytes(
+  ECRYPT_ctx* ctx,
+  u8* output,
+  u32 len)
+{
+  m64 s11, s12;
+  m64 s21, s22;
+  m64 s31, s32;
+
+  LOAD(ctx->state);
+
+  for (; (int32_t) len > 0; output += 16, len -= 16)
+    {
+      m64 t1, t2, t3, z[2];
+      UPDATE(); z[0] = XOR(XOR(s12, s22), s32); ROTATE();
+      UPDATE(); z[1] = XOR(XOR(s12, s22), s32); ROTATE();
+
+      M64TO64_CONVERT(z[0]); ((m64*)output)[0] = z[0];
+      M64TO64_CONVERT(z[1]); ((m64*)output)[1] = z[1];
+    }
+  STORE(ctx->state);
+
+  EMPTY();
+}
+
+
 /* ------------------------------------------------------------------------- */
